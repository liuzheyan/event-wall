<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>年会弹幕 - 发送端</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <style>
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden; /* 禁止页面滚动 */
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI";
      color: #fff;
    }

    /* ===== 用户端样式 ===== */
    .user-page {
      position: relative;
      height: 100%; /* Fallback */
      height: 100dvh;
      width: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      /* 背景图将通过 JS 动态设置 */
      background-size: cover;
      background-position: center;
    }

    .mask {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 0;
    }

    /* 顶部标题区 */
    .header {
      position: relative;
      z-index: 10;
      padding: 16px;
      text-align: center;
      background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
      flex-shrink: 0;
    }

    .header h2 {
      margin: 0;
      font-size: 20px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    /* 弹幕展示区（全屏漂浮） */
    .danmu-stage {
      position: relative;
      flex: 1; /* 占据剩余空间 */
      width: 100%;
      z-index: 5;
      pointer-events: none;
      overflow: hidden;
    }

    .danmu {
      position: absolute;
      white-space: nowrap;
      font-size: 20px; /* 手机端稍小一点 */
      color: #fff;
      animation: move linear forwards;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      will-change: transform;
    }

    .danmu.mine {
      color: #86efac; /* 自己发的弹幕高亮 */
      border: 1px solid rgba(134, 239, 172, 0.5);
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 8px;
      border-radius: 12px;
      z-index: 6; /* 稍微靠前 */
    }

    @keyframes move {
      from { transform: translateX(100vw); }
      to { transform: translateX(-100%); }
    }

    /* 底部输入区 */
    .input-area {
      position: relative;
      flex-shrink: 0;
      z-index: 10;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom)); /* 适配全面屏底部 */
      background: rgba(0,0,0,0.6); /* 保证输入框可见 */
      backdrop-filter: blur(4px);
    }

    .input-box {
      display: flex;
    }

    .input-box input {
      flex: 1;
      padding: 12px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      outline: none;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    .input-box button {
      margin-left: 8px;
      padding: 12px 16px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      background: #22c55e;
      color: #000;
      cursor: pointer;
      font-weight: bold;
    }

    .tip {
      text-align: center;
      font-size: 12px;
      color: #cbd5e1;
      margin-top: 8px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    /* Toast 提示框 */
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .toast.show {
      opacity: 1;
    }
  </style>
</head>
<body>

<div id="app">
  <div class="user-page" id="page">
    <div class="mask"></div>
    
    <div class="header">
      <!-- <h2>年会弹幕</h2> -->
    </div>

    <!-- 弹幕漂浮层 -->
    <div class="danmu-stage" id="danmuStage"></div>

    <div class="input-area">
      <div class="input-box">
        <input id="input" placeholder="说点什么吧（≤30字）" />
        <button id="send">发送</button>
      </div>
      <!-- <div class="tip">匿回车发送 · 3 秒限发 1 条</div> -->
    </div>
  </div>
</div>

<!-- Toast 容器 -->
<div id="toast" class="toast"></div>

<script src="js/config.js"></script>
<!-- 引入 MQTT.js -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
  /** ===== 通信频道 (MQTT) ===== */
  // 从 URL 参数获取 Topic
  const urlParams = new URLSearchParams(window.location.search);
  const topic = urlParams.get('topic') || CONFIG.MQTT_TOPIC; // Fallback
  
  // 简单生成一个 ID
  const clientId = "user_" + Math.random().toString(16).substr(2, 8);

  console.log("Connecting to MQTT Broker:", CONFIG.MQTT_BROKER);
  console.log("Topic:", topic);

  const client = mqtt.connect(CONFIG.MQTT_BROKER);

  client.on('connect', () => {
    console.log('MQTT Connected');
    client.subscribe(topic);
    showToast("已连接到弹幕墙");
  });

  client.on('error', (err) => {
    console.error("MQTT Error:", err);
    showToast("连接失败，请刷新重试");
  });

  /** ===== 逻辑 ===== */
  // 从配置读取背景图
  const { BG_IMAGE } = CONFIG;
  document.getElementById("page").style.backgroundImage = `url(${BG_IMAGE})`;

  let lastSend = 0;
  const input = document.getElementById("input");
  const sendBtn = document.getElementById("send");
  const danmuStage = document.getElementById("danmuStage");
  const toastEl = document.getElementById("toast");

  // 显示 Toast
  let toastTimer;
  function showToast(msg) {
    toastEl.innerText = msg;
    toastEl.classList.add("show");
    
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => {
      toastEl.classList.remove("show");
    }, 2000);
  }

  // 弹幕轨道控制
  // 手机屏幕较小，动态计算轨道数
  // 假设每条弹幕高 40px
  const TRACK_HEIGHT = 40;
  // 注意：这里需要重新获取 danmuStage 高度，或者监听 resize
  // 简单起见，取窗口高度的一半作为参考，或者直接用 random top
  let stageHeight = window.innerHeight * 0.6; 
  let TRACK_COUNT = Math.floor(stageHeight / TRACK_HEIGHT);
  let trackIndex = 0;

  // 待播放队列（高优先级，存放实时接收的用户弹幕）
  const pendingDanmus = [];
  let isPaused = false;

  function pushDanmu(text, isMine = false) {
    const el = document.createElement("div");
    el.className = `danmu ${isMine ? "mine" : ""}`;
    el.innerText = text;
    
    // 随机选择轨道，或者顺序循环
    const track = trackIndex % TRACK_COUNT;
    // top 使用百分比可能更安全，或者 px
    el.style.top = (track * TRACK_HEIGHT + 20) + "px"; // +20 padding
    
    // 随机速度 8s - 12s
    const duration = 8 + Math.random() * 4;
    el.style.animationDuration = `${duration}s`;
    
    if (isPaused) {
      el.style.animationPlayState = "paused";
    }

    trackIndex++;

    danmuStage.appendChild(el);
    el.addEventListener("animationend", () => el.remove());
  }

  function sendMessage() {
    const now = Date.now();
    if (now - lastSend < CONFIG.SEND_INTERVAL) {
      showToast("太频繁啦，稍等一会");
      return;
    }

    let text = input.value.trim();
    if (!text) {
      showToast("写点什么再发送吧~");
      return;
    }
    if (text.length > CONFIG.MAX_LEN) {
      showToast(`最多输入 ${CONFIG.MAX_LEN} 个字哦`);
      return;
    }

    text = filterText(text);

    // 发送给服务器
    const msg = JSON.stringify({
      type: 'danmu',
      text: text,
      time: now,
      id: clientId
    });
    client.publish(topic, msg);
    
    // 自己发的直接上屏 (可选：如果服务器回传太慢，本地先上屏)
    // 这里为了确保同步，也可以等服务器回传，但为了体验，本地先上屏
    // 并且标记 isMine
    // pushDanmu(text, true); // socket.on('danmu') 会收到自己的，如果不去重，会显示两次
    // 策略：本地不上屏，等服务器广播回来。或者本地上屏，忽略服务器回来的自己那条。
    // Socket.IO 默认 broadcast 不包含自己，但 io.emit 包含自己。
    // 在 server.js 中我使用了 io.emit，所以会包含自己。
    // 所以这里不要本地 pushDanmu，否则会重复。

    input.value = "";
    lastSend = now;
  }

  sendBtn.onclick = sendMessage;

  input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      sendMessage();
    }
  });

  // 监听广播
  client.on('message', (tpc, message) => {
      try {
        const msg = JSON.parse(message.toString());

        if (msg.type === 'danmu') {
             // 判断是不是自己发的
             const isMine = (msg.id === clientId); 
             pushDanmu(msg.text, isMine);
        } else if (msg.type === 'control') {
             const { action, paused } = msg;
             if (action === "toggle") {
                isPaused = paused; // 更新本地状态
                
                if (paused) {
                    showToast("管理员暂停了弹幕");
                    document.querySelectorAll(".danmu").forEach(el => {
                        el.style.animationPlayState = "paused";
                    });
                } else {
                    showToast("弹幕继续飘动~");
                    document.querySelectorAll(".danmu").forEach(el => {
                        el.style.animationPlayState = "running";
                    });
                }
             } else if (action === "clear") {
                document.querySelectorAll(".danmu").forEach(el => el.remove());
                showToast("管理员清空了屏幕");
             }
        }
      } catch(e) {
        console.error(e);
      }
  });

  // 默认弹幕循环（手机端也播放，营造氛围）
  setInterval(() => {
    if (isPaused) return;

    let text;
    // 优先播放实时队列 (其实 socket.on 已经直接 push 了，pendingDanmus 没用上)
    // 这里的 pendingDanmus 逻辑可以去掉了，直接 socket.on 就 push
    // 只有默认弹幕需要 interval
    
    // 闲时播放默认弹幕
    text = DEFAULT_DANMU[Math.floor(Math.random() * DEFAULT_DANMU.length)];
    // 手机端少发点默认弹幕，免得乱
    if(Math.random() > 0.5) return;
    
    pushDanmu(text);
  }, 3000); 

</script>

</body>
</html>
