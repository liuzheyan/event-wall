<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>年会弹幕 - 发送端</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <link rel="icon" href="img/favicon.ico" type="image/x-icon">
  <style>
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden; /* 禁止页面滚动 */
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI";
      color: #fff;
    }

    /* ===== 用户端样式 ===== */
    .user-page {
      position: relative;
      height: 100%; /* Fallback */
      height: 100dvh;
      width: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      /* 背景图将通过 JS 动态设置 */
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
    }

    .mask {
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    /* 顶部标题区 */
    .header {
      position: relative;
      z-index: 10;
      padding: 16px;
      text-align: center;
      background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
      flex-shrink: 0;
    }

    .header h2 {
      margin: 0;
      font-size: 20px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    /* 弹幕展示区（全屏漂浮） */
    .danmu-stage {
      position: fixed; /* 改为 fixed 全屏 */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%; /* 强制全屏高度，与 PC 端坐标系一致 */
      z-index: 5;
      pointer-events: none;
      overflow: hidden;
    }

    .danmu {
      position: absolute;
      white-space: nowrap;
      font-size: 26px; /* 手机端稍小一点 */
      color: #fff;
      animation: move linear forwards;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      will-change: transform;
    }

    .danmu.mine {
      color: #86efac; /* 自己发的弹幕高亮 */
      border: 1px solid rgba(134, 239, 172, 0.5);
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 8px;
      border-radius: 12px;
      z-index: 6; /* 稍微靠前 */
    }

    @keyframes move {
      from { transform: translateX(100vw); }
      to { transform: translateX(-100%); }
    }

    /* 底部输入区 */
    .input-area {
      margin-top: auto; /* 关键：在 flex 容器中自动推到最底部 */
      position: relative;
      flex-shrink: 0;
      z-index: 10;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom)); /* 适配全面屏底部 */
      background: rgba(0,0,0,0.6); /* 保证输入框可见 */
      backdrop-filter: blur(4px);
    }

    .input-box {
      display: flex;
    }

    .input-box input {
      flex: 1;
      padding: 12px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      outline: none;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
    }

    .input-box button {
      margin-left: 8px;
      padding: 12px 16px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      background: #22c55e;
      color: #000;
      cursor: pointer;
      font-weight: bold;
    }

    .tip {
      text-align: center;
      font-size: 12px;
      color: #cbd5e1;
      margin-top: 8px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    /* Toast 提示框 */
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .toast.show {
      opacity: 1;
    }
  </style>
</head>
<body>

<div id="app">
  <div class="user-page" id="page">
    <div class="mask"></div>
    
    <div class="header">
      <!-- <h2>年会弹幕</h2> -->
    </div>

    <!-- 弹幕漂浮层 -->
    <div class="danmu-stage" id="danmuStage"></div>

    <div class="input-area">
      <div class="input-box">
        <input id="input" placeholder="说点什么吧（≤30字）" />
        <button id="send">发送</button>
      </div>
      <!-- <div class="tip">匿回车发送 · 3 秒限发 1 条</div> -->
    </div>
  </div>
</div>

<!-- Toast 容器 -->
<div id="toast" class="toast"></div>

<script src="js/config.js"></script>
<!-- 引入 MQTT.js -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
  /** ===== 通信频道 (MQTT) ===== */
  // 从 URL 参数获取 Topic
  const urlParams = new URLSearchParams(window.location.search);
  const topic = urlParams.get('topic') || CONFIG.MQTT_TOPIC; // Fallback
  
  // 简单生成一个 ID
  const clientId = "user_" + Math.random().toString(16).substr(2, 8);

  console.log("Connecting to MQTT Broker:", CONFIG.MQTT_BROKER);
  console.log("Topic:", topic);

  const client = mqtt.connect(CONFIG.MQTT_BROKER);

  client.on('connect', () => {
    console.log('MQTT Connected');
    client.subscribe(topic);
    showToast("已连接到弹幕墙");
  });

  client.on('error', (err) => {
    console.error("MQTT Error:", err);
    showToast("连接失败，请刷新重试");
  });

  /** ===== 逻辑 ===== */
  // 从配置读取背景图
  // 优先使用手机端专用背景图，如果没有则回退到 PC 端背景图
  const bgImage = CONFIG.BG_IMAGE_MOBILE || CONFIG.BG_IMAGE;
  document.getElementById("page").style.backgroundImage = `url(${bgImage})`;

  let lastSend = 0;
  const input = document.getElementById("input");
  const sendBtn = document.getElementById("send");
  const danmuStage = document.getElementById("danmuStage");
  const toastEl = document.getElementById("toast");

  // 显示 Toast
  let toastTimer;
  function showToast(msg) {
    toastEl.innerText = msg;
    toastEl.classList.add("show");
    
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => {
      toastEl.classList.remove("show");
    }, 2000);
  }

  // 弹幕轨道控制
  // 关键修复：必须与大屏端保持一致的轨道数量 (12)，否则大屏发来的高轨道索引(如10,11)会导致手机端计算位置溢出屏幕
  const TRACK_COUNT = CONFIG.TRACK_COUNT || 12; 
  let trackIndex = 0;

  // 待播放队列（高优先级，存放实时接收的用户弹幕）
  const pendingDanmus = [];
  let isPaused = false;

  // === 轨道管理系统 ===
  // 记录每个轨道上次使用的时间
  const lastTrackTime = new Array(12).fill(0); // 默认为12，后续会根据 TRACK_COUNT 动态调整

  function getSmartTrack(totalTracks) {
    const now = Date.now();
    const MIN_INTERVAL = 2000; // 最小间隔 2 秒

    // 确保数组长度足够
    if (lastTrackTime.length !== totalTracks) {
        lastTrackTime.length = totalTracks;
        for(let i=0; i<totalTracks; i++) {
            if(!lastTrackTime[i]) lastTrackTime[i] = 0;
        }
    }

    // 计算每个轨道的空闲时间
    const trackStates = [];
    for(let i=0; i<totalTracks; i++) {
        trackStates.push({
            index: i,
            idleTime: now - (lastTrackTime[i] || 0)
        });
    }

    // 筛选出空闲时间超过阈值的轨道
    const validCandidates = trackStates.filter(t => t.idleTime > MIN_INTERVAL);

    let selectedTrack;

    if (validCandidates.length > 0) {
        // 如果有满足条件的轨道，从中随机选一个
        // 优先选空闲最久的几个，防止总是随机到刚过线的
        validCandidates.sort((a, b) => b.idleTime - a.idleTime);
        // 取前 50% 的空闲轨道进行随机
        const poolSize = Math.max(1, Math.ceil(validCandidates.length * 0.5));
        const pool = validCandidates.slice(0, poolSize);
        selectedTrack = pool[Math.floor(Math.random() * pool.length)].index;
    } else {
        // 如果都忙，选空闲时间最长的那个
        trackStates.sort((a, b) => b.idleTime - a.idleTime);
        selectedTrack = trackStates[0].index;
    }

    // 更新时间
    lastTrackTime[selectedTrack] = now;
    return selectedTrack;
  }
  // === 结束轨道管理 ===

  function getRandomColor() {
    const letters = '89ABCDEF'; 
    let color = '#';
    for (let i = 0; i < 6; i++) {
      // 修复：字符集长度为 8，应乘以 8
      color += letters[Math.floor(Math.random() * 8)];
    }
    return color;
  }

  function pushDanmu(text, isMine = false, options = {}) {
    // === 新增：后台不渲染 ===
    if (document.hidden) return;
    // === 结束新增 ===

    const el = document.createElement("div");
    el.className = `danmu ${isMine ? "mine" : ""}`;
    el.innerText = text;
    
    // 颜色处理：优先使用传入的颜色，否则使用随机颜色
    // 如果是自己发的，通常有特定样式，但也可能需要同步颜色？
    // 这里保持原逻辑：mine 用 CSS 样式，others 用传入颜色或随机
    if (!isMine) {
      el.style.color = options.color || getRandomColor();
    }
    
    // 随机选择轨道
    // 使用配置的轨道数，如果未定义则默认为 12
    const totalTracks = CONFIG.TRACK_COUNT || 12;
    // 优先使用传入的 track，否则使用智能分配
    const track = (typeof options.track === 'number') ? options.track : getSmartTrack(totalTracks);
    
    // 如果是外部传入的 track (比如系统弹幕)，我们也更新一下本地的 lastTrackTime，以免本地产生的弹幕跟它撞了
    if (typeof options.track === 'number') {
        // 确保数组初始化
        if (lastTrackTime.length !== totalTracks) {
            lastTrackTime.length = totalTracks;
            for(let i=0; i<totalTracks; i++) { if(!lastTrackTime[i]) lastTrackTime[i] = 0; }
        }
        if (track < lastTrackTime.length) {
            lastTrackTime[track] = Date.now();
        }
    }

    // 统一使用百分比布局
    // 计算 top 百分比: (track / totalTracks) * DANMU_AREA_PERCENT * 100
    // 另外加上一点顶部边距 (例如 5%)
    const areaPercent = CONFIG.DANMU_AREA_PERCENT || 0.75;
    const topPercent = (track / totalTracks) * areaPercent * 100 + 5; 
    el.style.top = topPercent + "%";
    
    // 统一时长
    el.style.animationDuration = (CONFIG.DANMU_DURATION || 12) + "s";
    
    if (isPaused) {
      el.style.animationPlayState = "paused";
    }

    trackIndex++;

    danmuStage.appendChild(el);
    el.addEventListener("animationend", () => el.remove());
  }

  function sendMessage() {
    const now = Date.now();
    if (now - lastSend < CONFIG.SEND_INTERVAL) {
      showToast("太频繁啦，稍等一会");
      return;
    }

    let text = input.value.trim();
    if (!text) {
      showToast("写点什么再发送吧~");
      return;
    }
    if (text.length > CONFIG.MAX_LEN) {
      showToast(`最多输入 ${CONFIG.MAX_LEN} 个字哦`);
      return;
    }

    // 敏感词检查
    if (hasSensitive(text)) {
      showToast("请文明用语~");
      return;
    }

    // text = filterText(text); // 不再需要替换，直接拦截

    // 生成随机显示参数
    const totalTracks = CONFIG.TRACK_COUNT || 12;
    // 使用智能轨道分配，避免重叠
    const track = getSmartTrack(totalTracks);
    const color = getRandomColor();

    // 发送给服务器
    const msg = JSON.stringify({
      type: 'danmu',
      text: text,
      time: now,
      id: clientId,
      // 携带显示参数，保证各端一致
      track: track,
      color: color
    });
    client.publish(topic, msg);

    // 调用 PHP 接口保存到本地文件
    fetch('api/Push.php', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: text,
        time: now
      })
    }).catch(err => {
      console.error("保存弹幕失败:", err);
    });
    
    // 立即本地上屏 (乐观 UI)，提升体验
    // 使用相同的参数渲染
    pushDanmu(text, true, { track, color });

    input.value = "";
    lastSend = now;
  }

  sendBtn.onclick = sendMessage;

  input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      sendMessage();
    }
  });

  // 默认弹幕循环控制
  // 策略：默认开启本地循环，保证单独打开手机端时有内容。
  // 一旦收到大屏端的广播 (sys_danmu)，说明大屏端在线，立即停止本地循环，完全听从大屏端指挥，以保证内容同步。
  
  // === 新增：页面恢复清理 ===
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
       // 切回前台时，清空积压队列，并移除屏幕上可能卡住的旧弹幕
       pendingDanmus.length = 0;
       document.querySelectorAll(".danmu").forEach(el => el.remove());
    }
  });
  // === 结束新增 ===

  let autoPlayTimer = setInterval(() => {
    if (isPaused) return;

    // 闲时播放默认弹幕
    const text = DEFAULT_DANMU[Math.floor(Math.random() * DEFAULT_DANMU.length)];
    // 手机端少发点默认弹幕，免得乱
    if(Math.random() > 0.5) return;
    
    pushDanmu(text);
  }, 3000); 

  // 监听广播
  client.on('message', (tpc, message) => {
      try {
        const msg = JSON.parse(message.toString());

        // === 新增：强一致性同步逻辑 ===
        // 只要收到任何来自服务器/大屏端的消息（包括用户弹幕、系统弹幕、控制指令）
        // 就认为大屏端在线（或环境活跃），立即停止本地的随机填充循环
        // 确保手机端看到的内容绝对是系统分发的，而不是本地瞎生成的
        if (autoPlayTimer) {
             clearInterval(autoPlayTimer);
             autoPlayTimer = null;
             console.log("检测到活跃信号，停止本地随机弹幕，转为绝对同步模式");
             
             // 清除屏幕上可能存在的本地随机弹幕，避免与即将到来的同步弹幕混淆/重复
             document.querySelectorAll(".danmu").forEach(el => el.remove());
             showToast("已同步大屏");
        }
        // === 结束新增 ===

        if (msg.type === 'danmu') {
             // 过滤掉自己发的（因为已经本地上屏了，避免重复）
             if (msg.id === clientId) return;
             // 接收远端传来的显示参数
             pushDanmu(msg.text, false, { track: msg.track, color: msg.color });
        } else if (msg.type === 'sys_danmu') {
             // 接收来自大屏端的默认弹幕广播
             
             // 核心逻辑：一旦收到大屏端的同步信号，关闭本地自动播放
             // (已在上方统一处理)
             /*
             if (autoPlayTimer) {
                 clearInterval(autoPlayTimer);
                 autoPlayTimer = null;
                 console.log("检测到大屏端在线，停止本地随机弹幕，转为同步模式");
             }
             */

             // 使用大屏端传来的显示参数
             pushDanmu(msg.text, false, { track: msg.track, color: msg.color });
        } else if (msg.type === 'control') {
             const { action, paused } = msg;
             if (action === "toggle") {
                isPaused = paused; // 更新本地状态
                
                if (paused) {
                    showToast("管理员暂停了弹幕");
                    document.querySelectorAll(".danmu").forEach(el => {
                        el.style.animationPlayState = "paused";
                    });
                } else {
                    showToast("弹幕继续飘动~");
                    document.querySelectorAll(".danmu").forEach(el => {
                        el.style.animationPlayState = "running";
                    });
                }
             } else if (action === "clear") {
                document.querySelectorAll(".danmu").forEach(el => el.remove());
                showToast("管理员清空了屏幕");
             }
        }
      } catch(e) {
        console.error(e);
      }
  });

  // (旧代码已清理) 

  // === 新增：Loading 状态与图片预加载兜底 ===
  (function() {
    // 1. 注入 Loading CSS
    const style = document.createElement('style');
    style.innerHTML = `
      ._fix_loading_overlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: opacity 0.5s ease;
      }
      ._fix_loading_spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: _fix_spin 1s ease-in-out infinite;
      }
      ._fix_loading_text {
        margin-top: 16px;
        color: #fff;
        font-size: 14px;
        opacity: 0.8;
      }
      @keyframes _fix_spin {
        to { transform: rotate(360deg); }
      }
      ._fix_fade_out {
        opacity: 0;
        pointer-events: none;
      }
    `;
    document.head.appendChild(style);

    // 2. 插入 Loading HTML
    const overlay = document.createElement('div');
    overlay.className = '_fix_loading_overlay';
    overlay.innerHTML = `
      <div class="_fix_loading_spinner"></div>
      <div class="_fix_loading_text">资源加载中...</div>
    `;
    document.body.appendChild(overlay);

    // 3. 图片预加载与移除逻辑
    function removeLoading() {
      overlay.classList.add('_fix_fade_out');
      setTimeout(() => {
        if (overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
      }, 500);
    }

    // 获取背景图 URL (从 CONFIG 中)
    if (typeof CONFIG !== 'undefined' && CONFIG.BG_IMAGE) {
      console.log("[Fix] Start preloading image:", CONFIG.BG_IMAGE);
      const img = new Image();
      img.onload = () => {
        console.log("[Fix] Image loaded successfully");
        removeLoading();
      };
      img.onerror = (e) => {
        console.error("[Fix] Image load failed", e);
        removeLoading(); // 失败也要移除，避免死锁
      };
      img.src = CONFIG.BG_IMAGE;

      // 超时兜底 (5秒)
      setTimeout(() => {
        if (!overlay.classList.contains('_fix_fade_out')) {
          console.warn("[Fix] Loading timeout");
          removeLoading();
        }
      }, 5000);
    } else {
      // 如果没有配置图片，直接移除
      removeLoading();
    }
  })();
  // === 结束新增 ===

</script>

</body>
</html>
